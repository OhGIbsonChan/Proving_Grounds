import streamlit as st
import pandas as pd
import numpy as np
import importlib
import pkgutil
import inspect
import sys
import base64
import io
import matplotlib.pyplot as plt
from backtesting import Backtest, Strategy
import config
from lib.data_loader import load_data
from strategies.base import BaseStrategy

# --- HELPER: AUTO-DISCOVER STRATEGIES ---
def get_strategies():
    strategies = {}
    package_name = 'strategies'
    if package_name not in sys.modules:
        import strategies
    package = sys.modules[package_name]
    for _, name, _ in pkgutil.iter_modules(package.__path__):
        if name == 'base': continue
        try:
            module = importlib.import_module(f'{package_name}.{name}')
            for member_name, member_obj in inspect.getmembers(module):
                if (inspect.isclass(member_obj) and issubclass(member_obj, Strategy) and 
                    member_obj is not Strategy and member_obj is not BaseStrategy):
                    strategies[member_name] = member_obj
        except Exception:
            pass
    return strategies

# --- HELPER: GENERATE EQUITY CURVE IMAGE ---
def get_equity_curve_image(equity_data):
    """
    Creates a lightweight PNG image of the equity curve for the report.
    """
    plt.figure(figsize=(6, 3))
    plt.plot(equity_data, color='#00cc44', linewidth=1.5)
    plt.title('Equity Curve', fontsize=10, color='#666')
    plt.grid(True, linestyle='--', alpha=0.3)
    plt.axis('off') # Hide axes for cleaner look
    
    # Save to buffer
    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight', transparent=False)
    plt.close()
    buf.seek(0)
    return base64.b64encode(buf.getvalue()).decode()

# --- HELPER: MOBILE REPORT GENERATOR ---
def create_mobile_report(stats, strategy_name, grade, grade_color, equity_img_b64):
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{ font-family: -apple-system, sans-serif; background: #f0f2f6; padding: 20px; }}
            .card {{ background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }}
            h1 {{ font-size: 20px; margin: 0 0 10px 0; color: #333; }}
            .grade {{ float: right; padding: 5px 15px; border-radius: 20px; color: white; font-weight: bold; background: {grade_color}; }}
            .metric {{ display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #eee; }}
            .metric:last-child {{ border-bottom: none; }}
            .label {{ color: #666; }}
            .value {{ font-weight: bold; color: #333; }}
            .chart-container {{ text-align: center; margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; }}
            img {{ max-width: 100%; height: auto; border-radius: 10px; }}
            .footer {{ text-align: center; color: #888; font-size: 12px; }}
        </style>
    </head>
    <body>
        <div class="card">
            <span class="grade">{grade.split(' ')[0]}</span>
            <h1>{strategy_name}</h1>
            <p style="color: #666; font-size: 14px; margin-top: -5px;">Performance Report</p>
            
            <div class="metric"><span class="label">Total Return</span><span class="value">{stats['Return [%]']:.2f}%</span></div>
            <div class="metric"><span class="label">Win Rate</span><span class="value">{stats['Win Rate [%]']:.2f}%</span></div>
            <div class="metric"><span class="label">Profit Factor</span><span class="value">{stats['Profit Factor']:.2f}</span></div>
            <div class="metric"><span class="label">Max Drawdown</span><span class="value">{stats['Max. Drawdown [%]']:.2f}%</span></div>
            
            <div class="chart-container">
                <img src="data:image/png;base64,{equity_img_b64}" alt="Equity Curve">
            </div>
        </div>

        <div class="card">
            <h3>Advanced Metrics</h3>
            <div class="metric"><span class="label">Sharpe Ratio</span><span class="value">{stats['Sharpe Ratio']:.2f}</span></div>
            <div class="metric"><span class="label">Sortino Ratio</span><span class="value">{stats['Sortino Ratio']:.2f}</span></div>
            <div class="metric"><span class="label">Kelly Criterion</span><span class="value">{stats['Kelly Criterion']:.2f}</span></div>
            <div class="metric"><span class="label">SQN</span><span class="value">{stats['SQN']:.2f}</span></div>
            <div class="metric"><span class="label">Total Trades</span><span class="value">{stats['# Trades']}</span></div>
        </div>
        
        <div class="footer">Generated by Proving Grounds</div>
    </body>
    </html>
    """
    return html

def calculate_grade(stats):
    pf = stats['Profit Factor']
    dd = abs(stats['Max. Drawdown [%]'])
    if stats['# Trades'] < 30: return "N/A", "gray"
    if pf < 1.0: return "F (Fail)", "red"
    
    score = 0
    if pf > 2.0: score += 3
    elif pf > 1.5: score += 2
    
    if dd < 10: score += 3
    elif dd < 20: score += 2
    
    if score >= 5: return "A (Excellent)", "green"
    if score >= 3: return "B (Good)", "orange"
    return "C (Mediocre)", "gray"

# --- MAIN ---
st.set_page_config(page_title="Proving Grounds", layout="wide")
st.title("üß™ Proving Grounds: Strategy Lab")

# Sidebar
STRAT_MAP = get_strategies()
selected_strat_name = st.sidebar.selectbox("Select Strategy", list(STRAT_MAP.keys()))
SelectedStrategy = STRAT_MAP[selected_strat_name]

# Load data once to get the global date range
@st.cache_data
def get_data_bounds():
    df = load_data(config.DATA_PATH, timeframe="1h") # Use 1h for speed just to get dates
    return df.index.min(), df.index.max()

min_data_date, max_data_date = get_data_bounds()

# --- SIDEBAR UPDATES ---
st.sidebar.header("‚è±Ô∏è Timeframe & Data Split")
selected_tf = st.sidebar.selectbox("Select Timeframe", ["1min", "5min", "15min", "1h"], index=0)
initial_cash = st.sidebar.number_input("Starting Cash ($)", value=100000)
leverage = st.sidebar.slider("Leverage", 1, 50, 20)
comm = st.sidebar.number_input("Comm ($)", value=1.25) / 30000 
# NEW: Slippage Input (as a percentage of price)
slippage_pct = st.sidebar.number_input("Slippage (%)", value=0.01, step=0.01) / 100
total_friction = comm + slippage_pct

# Dynamic Date Range for OSS
# We use the min/max from the actual data file here
col_start, col_end = st.sidebar.columns(2)
start_date = col_start.date_input(
    "Start Date", 
    value=min_data_date.date(),
    min_value=min_data_date.date(),
    max_value=max_data_date.date()
)
end_date = col_end.date_input(
    "End Date", 
    value=max_data_date.date(),
    min_value=min_data_date.date(),
    max_value=max_data_date.date()
)

params = {}
if hasattr(SelectedStrategy, 'risk_reward'): params["risk_reward"] = st.sidebar.number_input("Risk/Reward", value=float(SelectedStrategy.risk_reward))
if hasattr(SelectedStrategy, 'stop_loss_padding'): params["stop_loss_padding"] = st.sidebar.number_input("SL Padding", value=float(SelectedStrategy.stop_loss_padding))
if hasattr(SelectedStrategy, 'swing_lookback'): params["swing_lookback"] = st.sidebar.slider("Lookback", 2, 20, int(SelectedStrategy.swing_lookback))

if st.button("üöÄ Run Backtest"):
    with st.spinner("Crunching..."):
        try:
            # 1. Load data
            df = load_data(config.DATA_PATH, timeframe=selected_tf)

            # 2. Fix Timezone Mismatch for Slicing
            # Convert date objects to localized timestamps to match df.index
            tz = "America/New_York"
            start_ts = pd.Timestamp(start_date).tz_localize(tz)
            end_ts = pd.Timestamp(end_date).tz_localize(tz).replace(hour=23, minute=59, second=59)
            
            df = df.loc[start_ts:end_ts]
            
            if df.empty:
                st.error("No data available for the selected date range.")
            else:
                # 3. Initialize and RUN inside the 'else' block
                bt = Backtest(
                    df, 
                    SelectedStrategy, 
                    cash=initial_cash, 
                    commission=total_friction, 
                    margin=1/leverage, 
                    trade_on_close=False
                )
                
                stats = bt.run(**params)
            
                # --- Generate Assets ---
                grade, color = calculate_grade(stats)
                equity_curve = stats['_equity_curve']['Equity']
                
                # Downsample for PNG generation (speed up)
                if len(equity_curve) > 2000:
                    equity_curve_img_data = equity_curve.iloc[::len(equity_curve)//2000]
                else:
                    equity_curve_img_data = equity_curve
                    
                img_b64 = get_equity_curve_image(equity_curve_img_data)
                report_html = create_mobile_report(stats, selected_strat_name, grade, color, img_b64)
                
                # --- Display ---
                st.markdown(f"<h2 style='color:{color}'>Grade: {grade}</h2>", unsafe_allow_html=True)
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Return", f"{stats['Return [%]']:.2f}%")
                col2.metric("Profit Factor", f"{stats['Profit Factor']:.2f}")
                col3.metric("Sortino", f"{stats['Sortino Ratio']:.2f}")
                col4.metric("Kelly", f"{stats['Kelly Criterion']:.2f}")
                
                b64 = base64.b64encode(report_html.encode()).decode()
                href = f'<a href="data:text/html;base64,{b64}" download="report_mobile.html"><button style="background:#ff4b4b;color:white;padding:10px;border:none;border-radius:5px;cursor:pointer;">üì± Download Mobile Report</button></a>'
                st.markdown(href, unsafe_allow_html=True)

                # --- 5. DESKTOP DETAILED VIEW ---
                st.markdown("---")
                st.subheader("üñ•Ô∏è Desktop Dashboard")

                # A. Interactive Equity Curve (Downsampled for Speed)
                st.caption("Equity Curve (Interactive)")
                equity_curve = stats['_equity_curve']['Equity']
                
                # Downsample: If > 5000 points, show every Nth point to prevent crashing
                if len(equity_curve) > 5000: 
                    downsample_rate = len(equity_curve) // 5000
                    st.line_chart(equity_curve.iloc[::downsample_rate])
                else:
                    st.line_chart(equity_curve)

                # B. Full Statistics Table (Sanitized)
                # We convert to string to prevent the "PyArrow/Streamlit" error
                clean_stats = stats.drop(['_equity_curve', '_trades', '_strategy'], errors='ignore')
                clean_stats_df = clean_stats.to_frame(name="Value").astype(str)

                with st.expander("üìä View Full Statistics", expanded=True):
                    st.dataframe(clean_stats_df, use_container_width=True)

                # --- NEW: MONTE CARLO SIMULATION SECTION ---
                st.markdown("---")
                st.subheader("üé≤ Monte Carlo Risk Analysis")

                # Sidebar settings for Monte Carlo
                n_simulations = st.sidebar.slider("MC Iterations", 100, 1000, 500)
                sample_size = len(stats['_trades'])

                if sample_size > 10:
                    trades_pnl = stats['_trades']['PnL'].values
                    
                    # Run Simulations
                    mc_results = []
                    for _ in range(n_simulations):
                        # Shuffle the trades with replacement
                        sim_trades = np.random.choice(trades_pnl, size=sample_size, replace=True)
                        # Calculate equity curve for this simulation
                        sim_equity = np.cumsum(sim_trades) + initial_cash
                        mc_results.append(sim_equity)
                    
                    # Plotting
                    fig, ax = plt.subplots(figsize=(10, 5))
                    for run in mc_results[:100]: # Plot first 100 paths for clarity
                        ax.plot(run, color='gray', alpha=0.1, linewidth=0.5)
                    
                    # Highlight the 5th and 95th percentile paths
                    mc_array = np.array(mc_results)
                    ax.plot(np.percentile(mc_array, 95, axis=0), color='green', label='95th Percentile', linewidth=2)
                    ax.plot(np.percentile(mc_array, 5, axis=0), color='red', label='5th Percentile (Worst Case)', linewidth=2)
                    ax.plot(np.mean(mc_array, axis=0), color='blue', label='Average Path', linestyle='--')
                    
                    ax.set_title(f"Monte Carlo: {n_simulations} Shuffled Equity Paths")
                    ax.set_ylabel("Account Balance ($)")
                    ax.set_xlabel("Trade Number")
                    ax.legend()
                    st.pyplot(fig)

                    # Risk Metrics
                    final_balances = mc_array[:, -1]
                    ruin_count = np.sum(final_balances < initial_cash)
                    
                    m_col1, m_col2, m_col3 = st.columns(3)
                    m_col1.metric("Prob. of Profit", f"{(1 - ruin_count/n_simulations)*100:.1f}%")
                    m_col2.metric("Median Final Equity", f"${np.median(final_balances):,.0f}")
                    m_col3.metric("Max MC Drawdown", f"${(np.max(mc_array) - np.min(mc_array)):,.0f}")
                else:
                    st.warning("Not enough trades to run a reliable Monte Carlo simulation.")

                # C. Trade Log (Sanitized & Limited)
                trades = stats['_trades'].copy()
                
                # Fix Duration formatting
                if 'Duration' in trades.columns:
                    trades['Duration'] = trades['Duration'].astype(str)
                
                # Limit to last 2000 trades to prevent "Out of Memory"
                if len(trades) > 2000:
                    st.warning(f"‚ö†Ô∏è Showing last 2,000 trades (Total: {len(trades)}) to save memory.")
                    trades = trades.iloc[-2000:]
                    
                with st.expander("üìù View Trade Log"):
                    st.dataframe(trades.astype(str), use_container_width=True)

        except Exception as e:
            st.error(f"Error: {e}")
            import traceback
            st.code(traceback.format_exc())